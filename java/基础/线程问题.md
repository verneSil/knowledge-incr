# 多线程问题

## 问题列表
1. 线程伪共享 [伪共享（false sharing），并发编程无声的性能杀手 - cyfonly - 博客园](https://www.cnblogs.com/cyfonly/p/5800758.html)
2. Semaphore，CountDownLatch，CyclicBarrier
    [JUC——线程同步辅助工具类（Semaphore，CountDownLatch，CyclicBarrier） - iTermis - 博客园](https://www.cnblogs.com/itermis/p/9004041.html)
3. Java 中，编写多线程程序的时候你会遵循哪些最佳实践？
   ```
   这是我在写Java 并发程序的时候遵循的一些最佳实践：

   a）给线程命名，这样可以帮助调试。

   b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。

   c）如果可以，更偏向于使用 volatile 而不是 synchronized。

   d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。

   e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。
   ```
4. Java 内存模型是什么

    Java 内存模型规定和指引 Java 程序在不同的内存架构、CPU 和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让程序员在并发编程时思路更清晰。

    线程内的代码能够按先后顺序执行，这被称为程序次序规则。

    对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。

    前一个对volatile的写操作在后一个volatile的读操作之前，也叫volatile变量规则。

    一个线程内的任何操作必需在这个线程的 start ()调用之后，也叫作线程启动规则。

    一个线程的所有操作都会在线程终止之前，线程终止规则。

    一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。

    a先行于b，b先行于c，传递性

5. 死锁
    如何避免死锁？

    死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：

        互斥条件：一个资源每次只能被一个进程使用。

        请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

        不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。

        循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

    避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。
