## 类加载
jvm把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成jvm可以直接执行的java类型的过程

加载->验证->准备->解析->初始化->使用->卸载

从类被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括如上的7个阶段。其中，验证、准备、解析这三个部分又被统称为“连接（Linking）。类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定，它在某些情况下是可以在初始化阶段之后再开始的，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。

什么情况下需要开始类加载的第一个阶段：加载？Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，虚拟机规范要求有且只有5种情况必须立即对类进行初始化（加载、验证、准备需要在此之前开始）：

1.遇到new、getstatic、putstatic、invokestatic这4条字节码指令时。生成这4条指令最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。

2.使用java.lang.reflect包方法对类进行反射调用的时候。

3.当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。

4.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()的那个类），虚拟机会先初始化这个主类。

5.当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，则需要先触发这个方法句柄所对应的类的初始化。


## 双亲委托机制
如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载

>* BootstrapClassLoader -> ExtensionClassLoader -> AppClassLoader -> 自定义

### 破坏双亲委托机制
##### SPI如何破坏的
在某些情况下父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件。
以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派
http://www.itdaan.com/blog/2018/07/14/8c9f99b6632e703f3ca7b023c8a2cebf.html

##### 容器隔离
一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。两个应用程序采用不同的ClassLoader加载。

##### 热部署，模块化
为了实现热插拔，热部署，模块化，意思是添加一个功能或减去一个功能不用重启，只需要把这模块连同类加载器一起换掉就实现了代码的热替换。
比如web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。Tomcat的实现方式是为每个Jsp分配一个ClassLoader，当jsp文件更新的时候，就卸载掉ClassLoader，重新加载。
commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；
catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；
sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；
WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；
